import numpy as np


def swap(array):
    """
    get a new array where two elements of the original array are swapped
    input:
        array((2,n),ndarray)

    output:
        array_swapped((2,n),ndarray)
    """
    array_swapped = np.zeros((len(array), len(array[0])), dtype=int)
    array_swapped[0], array_swapped[1] = array[1], array[0]
    return array_swapped


def get_distance_matrix(pocket_coords, ligand_coords):
    """
    get the distance matrix (protein_atoms-ligand_atoms) of a complex
    inputï¼š
        pocket_coords (ndarray, (num_of_pocket_atoms, 3))
        ligand_coords (ndarray, (num_of_ligand_atoms, 3))

    output:
        distance matrix ((num_of_pocket_atoms, num_of_ligand_atoms), ndarray):the distance matrix of the complex
    """
    distance_matrix = np.sqrt(np.sum(np.square(
        pocket_coords.reshape([-1, 1, 3]) - ligand_coords.reshape([1, -1, 3])
    ), axis=-1))
    return distance_matrix


def get_atoms_within_cutoff(cutoff, pocket_coords, ligand_coords, pocket_features, pocket_vdw):
    """
    get pocket atoms within the cutoff
    input:
        cutoff (float)
        pocket_coords (ndarray, (num_of_pocket_atoms, 3))
        ligand_coords (ndarray, (num_of_ligand_atoms, 3))
        pocket_features (ndarray, (num_of_ligand_atoms, 19))
        pocket_vdw (ndarray,num_of_pocket_atoms)

    output:
        pocket_coords_reserv (ndarray, (num_of_pocket_atoms_within_cutoff, 3))
        pocket_features_reserv (ndarray, (num_of_ligand_atoms_within_cutoff, 19))
        pocket_vdw_reserv (ndarray,num_of_pocket_atoms_within_cutoff)
    """
    distance_matrix = get_distance_matrix(pocket_coords, ligand_coords)

    # get indices of atoms with cutoff
    indices_reserv = []
    for i in range(len(pocket_coords)):
        if min(distance_matrix[i]) <= cutoff:
            indices_reserv.append(i)

    pocket_coords_reserv = np.take(pocket_coords, indices_reserv, axis=0)
    pocket_features_reserv = np.take(pocket_features, indices_reserv, axis=0)
    pocket_vdw_reserv = np.take(pocket_vdw, indices_reserv, axis=0)

    return pocket_coords_reserv, pocket_features_reserv, pocket_vdw_reserv


def get_edge_inter(pocket_coords, ligand_coords, cutoff):
    """
    input:
    pocket_coords (ndarray, (num_of_pocket_atoms, 3))
        ligand_coords (ndarray, (num_of_ligand_atoms, 3))

    output:
    edge_inter_ind((2, 2*num_of_edge_inter), ndarray)
    edge_inter_attr((2*num_of_edge_inter, num_of_edge_features), ndarray)
    """
    distance_matrix = get_distance_matrix(pocket_coords, ligand_coords)

    d1 = 2 + (cutoff - 2) / 3
    d2 = 2 + 2 * (cutoff - 2) / 3
    edge_inter_ind1 = np.array(np.where((distance_matrix > 2) & (distance_matrix <= d1)))
    edge_inter_ind2 = np.array(np.where((distance_matrix > d1) & (distance_matrix <= d2)))
    edge_inter_ind3 = np.array(np.where((distance_matrix > d2) & (distance_matrix <= cutoff)))

    # correct pocket atom index (+ number of ligand atoms)
    add = len(distance_matrix[0])
    edge_inter_ind1[0] = edge_inter_ind1[0] + add
    edge_inter_ind2[0] = edge_inter_ind2[0] + add
    edge_inter_ind3[0] = edge_inter_ind3[0] + add

    # get swapped indices
    swap1, swap2, swap3 = swap(edge_inter_ind1), swap(edge_inter_ind2), swap(edge_inter_ind3)

    # get indices of intermolecular edges
    edge_inter_ind = np.concatenate((edge_inter_ind1, swap1, edge_inter_ind2, swap2, edge_inter_ind3, swap3), axis=1)

    # generate feature vectors of different types of intermolecular edges
    edge_inter_attr1 = np.zeros(8)
    edge_inter_attr2 = np.zeros(8)
    edge_inter_attr3 = np.zeros(8)
    edge_inter_attr1[5] = 1
    edge_inter_attr2[6] = 1
    edge_inter_attr3[7] = 1

    # get attributes of intermolecular edges
    edge_inter_attr = []
    for i in range(2*len(edge_inter_ind1[0])):
        edge_inter_attr.append(edge_inter_attr1)
    for i in range(2*len(edge_inter_ind2[0])):
        edge_inter_attr.append(edge_inter_attr2)
    for i in range(2*len(edge_inter_ind3[0])):
        edge_inter_attr.append(edge_inter_attr3)

    edge_inter_attr = np.array(edge_inter_attr)

    return edge_inter_ind, edge_inter_attr


def bond_features(bond):
    """
    get bond features
    input:
    bond(OBBond)

    output:
    fbond((5,), ndarray): features of the bond
    """
    fbond = np.array([bond.GetBondOrder() == 1, bond.GetBondOrder() == 2, bond.GetBondOrder() == 3, bond.IsAromatic(), bond.IsInRing(), 0, 0, 0])
    return fbond


def get_ind_mapping(features):
    """
    get the mapping from atomic indices in molecule to those in final representation
    input:
    features((num_of_atom_resv, 20), ndarray): the features of the molecule generated by Featurizer()

    output:
    mapping(num_of_atom_resv, dictionary):
        key: atomic indices in molecule
        val: atomic indices in final representation
    """
    ind_list = features[:, 0]
    ind_mapping = {}
    for ind_rep, ind_mol in enumerate(ind_list):
        ind_mapping[ind_mol] = ind_rep
    return ind_mapping


def correct_ind(bond_ind, bond_attr, features):
    """
    correct bond_ind, bond_attr and then get edge_bond_ind, edge_bond_attr
    input:
    bond_ind((2, 2*num_of_bond), ndarray)
    bond_attr((2*num_of_bond, num_of_edge_features), ndarray)
    features((num_of_atom_resv, 20), ndarray): the features of the molecule generated by Featurizer()

    output:
    edge_bond_ind((2, 2*num_of_edge_bond), ndarray)
    edge_bond_attr((2*num_of_edge_bond, num_of_edge_features), ndarray)
    """
    ind_list = features[:, 0]
    ind_mapping = get_ind_mapping(features)

    # delete the atoms outside consideration
    del_list = []
    for i in range(len(bond_ind)):
        for j in range(len(bond_ind[0])):
            if bond_ind[i, j] not in ind_list:
                del_list.append(j)

    del_list = list(set(del_list))
    edge_bond_ind = np.delete(bond_ind, del_list, 1)
    edge_bond_attr = np.delete(bond_attr, del_list, 0)

    # replace atomic indices in molecule with those in final representation
    for i in range(len(edge_bond_ind)):
        for j in range(len(edge_bond_ind[0])):
            ind_mol = edge_bond_ind[i, j]
            edge_bond_ind[i, j] = ind_mapping[ind_mol]

    return edge_bond_ind, edge_bond_attr


def get_edge_bond(mol, features):
    """
    get indices and attributes of the bond edges
    input:
    mol(pybel.Molecule): molecule

    output:
    edge_bond_ind((2, 2*num_of_edge_bond), ndarray)
    edge_bond_attr((2*num_of_edge_bond, num_of_edge_features), ndarray)
    """
    bonded_atom_pairs = []
    bond_attr = []
    for i in range(mol.OBMol.NumBonds()):
        bond = mol.OBMol.GetBond(i)
        bonded_atom_pairs.append((bond.GetBeginAtomIdx(), bond.GetEndAtomIdx()))
        bonded_atom_pairs.append((bond.GetEndAtomIdx(), bond.GetBeginAtomIdx()))
        fbond = bond_features(bond)
        bond_attr.append(fbond)
        bond_attr.append(fbond)

    bond_ind = np.array(bonded_atom_pairs).T
    bond_attr = np.array(bond_attr)
    edge_bond_ind, edge_bond_attr = correct_ind(bond_ind, bond_attr, features)

    return edge_bond_ind, edge_bond_attr







